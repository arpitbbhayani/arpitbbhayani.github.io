<div class="ui hidden divider"></div>

<div itemscope="" itemtype="http://schema.org/BlogPosting">
    <article>
        <h1 itemprop="name headline" class="ui huge header center aligned">
            <b>Benchmark and compare the two approaches to paginate in MongoDB</b>
        </h1>
        
        <div itemprop="image" itemscope itemtype="https://schema.org/ImageObject">
            <meta itemprop="url" content="https://arpitbhayani.me/static/images/mongodb-pagination/benchmark-and-compare.jpg" />
            <img itemprop="image" class="ui centered large image" src="https://arpitbhayani.me/static/images/mongodb-pagination/benchmark-and-compare.jpg" alt="Benchmark and compare the two approaches to paginate in MongoDB" />
        </div>
        
        <div class="ui hidden section divider"></div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-9220578038638789"
     data-ad-slot="2902722754"
     data-ad-format="auto"></ins>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({});
</script>
<div class="ui hidden section divider"></div>

        <div itemprop="articleBody">
            <p><a href="https://www.mongodb.com/">MongoDB</a> is a document based data store and hence pagination is one of the most common use case of it. So when do you paginate the response? The answer is pretty neat; you paginate whenever you want to process result in chunks. Some common scenarios are</p>

<ul>
  <li>Batch processing</li>
  <li>Showing huge set of results on user interface</li>
</ul>

<p>There are multiple approaches through which you can <a href="/techie/fast-and-efficient-pagination-in-mongodb.html">paginate your result set in MongoDB</a>. This blog post is dedicated for results of benchmark of two approaches and its analysis, so here we go …</p>

<p>Benchmark has been done over a non-indexed collection. Each document of the collection looks something like this</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span></span>    <span class="p">{</span>
        <span class="s2">&quot;_id&quot;</span> <span class="o">:</span> <span class="nx">ObjectId</span><span class="p">(</span><span class="s2">&quot;5936d17263623919cd5165bd&quot;</span><span class="p">),</span>
        <span class="s2">&quot;name&quot;</span> <span class="o">:</span> <span class="s2">&quot;Lisa Rogers&quot;</span><span class="p">,</span>
        <span class="s2">&quot;marks&quot;</span> <span class="o">:</span> <span class="mi">34</span>
    <span class="p">}</span></code></pre></figure>

<p>All records of a collection are fetched page-wise. Size of each page is fixed during fetch of the collection. Each page is fetched <em>3</em> times and average of, time to fetch one “page”, 3 is recorded.</p>

<p>Following image shows the how two approach fares against each other.</p>

<p><img class="ui huge centered stylish image" src="/static/images/mongodb-pagination/mongo-pagination-benchmark-results.png" alt="Benchmark results" /></p>

<p>A key observation to note is that, till 500-600 count, both the approaches are comparable, but once it crosses that threshold, there is sudden rise in response time for <code>skip</code> and <code>limit</code> approach than other. The approach using <code>_id</code> and <code>limit</code> almost gives constant performance and is independent of size of the result set.</p>

<p>I tried running this test on different machines with different disks but results were similar. I think diving deep in MongoDB’s database drivier will yield better information about this behavior. You could see some spikes in the response times, that are because of Disk Contention.</p>

<p>In short:</p>
<ul>
  <li>For huge result set, paginating using <code>_id</code> and <code>limit</code> is far better than using <code>skip</code> and <code>limit</code>.</li>
  <li>For smaller result set, it does not matter, but prefer skip and limit.</li>
</ul>

<p>An interesting thing I observed is that after page size crosses 100, the gap between the two approach reduces to some extent. I am yet to perform detailed benchmark on that as such use-case (where page-size is more than 100) is pretty rare in practical applications.</p>

<p>You can find the Python code used for this benchmark <a href="https://github.com/arpitbbhayani/mongo-pagination-benchmark">here</a>. If you have any suggestion or improvement, do let me know.</p>

        </div>
    </article>
</div>

<div class="ui hidden section divider"></div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-9220578038638789"
     data-ad-slot="2902722754"
     data-ad-format="auto"></ins>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({});
</script>
<div class="ui hidden section divider"></div>



    <div class="ui basic segment" style="background: #FFF">
    <div id="disqus_thread"></div>
</div>

<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
this.page.url = "https://arpitbhayani.me/techie/benchmark-and-compare-pagination-approach-in-mongodb.html";  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = "/techie/benchmark-and-compare-pagination-approach-in-mongodb.html"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//arpitbbhayani.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


